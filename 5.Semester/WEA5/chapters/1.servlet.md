# Servlets

## Overview
- Three-Tier Architecture 
- Implementation Overview 
- Servlet Life Cycle 
- Session Management 
- Web Application 
- Sharing Resources 
- Database Connection Pooling (DBCP) 
- Non-Blocking IO
- Annotations

## Multi-Tier-Architecture
- Tier 1 – Client - **User Interface** 
  - Handles the user-interface, presenting information as well as getting user input

- Tier 2 – Middle Tier Server - **Business Logic** 
  - Accepts requests from Client, issues requests to back-end, performs business logic processing, and send responses to Clients

- Tier 3 – Back-end Server - **Data Management** 
  - Manage the data and perform data retrieval upon receiving requests from the Middle-Tier Server
  
### Vorteile

### Nachteile

#### Challenges
 - Technologies are changing fast • Specific technologies are their code should be encapsulated somehow, to change them easily
- Access to the back end must not compromise security - Front-end access devices can be very diverse (PCs, Tablets, Smartphones, etc.)
    - Widely varying user interface (UI) capabilities have to be supported * UIs on displays with varying quality and size * Automatic speech recognition and natural language understanding
    - Most systems are designed with a specific client device and UI in mind * It is difficult to extend the service’s range of target devices without modifying the service itself
    - Additional support of new devices should be able with minimal effort

#### Fat-Client versus Thin-client
Thin Client: An beliebiger Stelle könnte man die Anwendung aufteilen.

<img src="../pics/1.FatVsThin.PNG" alt="ThinVsFatClient" width="350"/>

#### Architecture
Server Presentation Layer wenn serverseitiges Rendering.  
Persistence: SQL Abfragen, Caching verringert DB Anfragen
Content Repos: DB, Javaseitig gibt es API für zugriff.

<img src="../pics/2.Architecture.PNG" alt="Architecture" width="350"/>


## Characteristics

#### Servlets

- Small Java-based applications
- Programming model is
similar to CGI scripts • Mapping HTTP requests into HTTP responses
- Address the problem of doing server-side programming with platformspecific APIs
- All of the servlets associated with a Web server run inside a single
process

<img src="../pics/3.PNG" alt="Servlets" width="350"/>

- Servlets are persistent 
    -  Unlike CGI scripts, a Servlet`s lifecycle extends beyond HTTP each request
    - Servlet container manages the lifecycle of the Servlet and handles the socket-level communication
- Useful for implementing a **multi-tier architecture**

CGI startet eigenen Prozess nicht eigenen Thread -> schwergewichtig  
Servlet (Thread) bleibt nach erstmaligen Aufruf bestehen und läuft weiter
Tomcat default 10000 User (Thread)

## Implementation Overview
<img src="../pics/4.PNG" alt="Servlets" width="450"/>


## Servlet Life Cycle

- Servlet Package (javax.servlet) 
    - Interfaces 
        - RequestDispatcher, Servlet, ServletConfig, ServletContext, ServletRequest, ServletResponse, SingleThreadModel
    - Classes 
        -  GenericServlet, ServletInputStream, ServletOutputStream, ServletException, UnavailableException
- Servlet Package (javax.servlet.http) 
    - Interfaces 
        - HttpServletRequest, HttpServletResponse, HttpSession, HttpSessionBindingListener, HttpSessionContext
    - Classes 
        - Cookie, HttpServlet, HttpSessionBindingEvent,
HttpUtils

### Simple but Complete Servlet code example
```java
public class SimpleServlet extends HttpServlet { /* Handle the HTTP GET method by building a simple web page. */ 
public void doGet (HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException { 
        PrintWriter out;

        String title = "Simple Servlet Output"; 
        // set content type and other response header fields first  
        response.setContentType("text/html"); 
        // then write the data of the response 
        out = response.getWriter(); // CRLF in the response
        out.println("<HTML><HEAD><TITLE>"); 
        out.println(title);
        out.println("</TITLE></HEAD><BODY>"); 
        out.println("<H1>" + title + "</H1>"); 
        out.println("<P> This is output from SimpleServlet."); 
        out.println("</BODY></HTML>"); 
        out.close();
    }
}
```
Zuerst müssen Header geschrieben werden dann der Body. Siehe Bild
<img src="../pics/5.PNG" alt="Servlets" width="400"/>

- Each servlet has the same life cycle: 
  - A server loads and initializes the servlet 
  - Servlet handles zero or more client requests 
  - Server removes the servlet
    - Some servers do this step only when they shut down  

  <img src="../pics/6.PNG" alt="Servlets" width="350"/>

#### Initializing a Servlet
- Initializing a Servlet 
  - Server calls the init method **once**, and 
  - Server will not call the init method again unless the server is reloading the servlet
  - Server can not reload a servlet until the server has destroyed the servlet by running the destroy method
  - A user has to override init method to provide a specific implementation
  
#### Rules for overriding init
- Rules for overriding init 
  - If an initialization error occurs, throw an UnavailableException 
    - e.g. if a required network connection cannot be established
    - Do not call the System.exit method

#### Threading Issues
- Threading Issues 
  - Servlets are typically capable of serving multiple clients concurrently
  - If clients access a shared resource, then a servlet should handle only one client request at a time
  - Servlet has to implement the **SingleThreadModel** interface • Does not involve writing any extra (interface has no methods) • If the servlet implements this interface, the servlet will be thread safe.
  - Note that this will not prevent synchronization problems associated with accessing shared resources (such as static
class variables or classes outside the scope of the servlet)

  <img src="../pics/7.PNG" alt="Servlets" width="350"/>

## Session Management
#### What is a session?
- A connection is maintained while the two end points are communicating back and forth in a conversation or **session** of some duration
- Some connections and sessions last only long enough to send a message in one direction
- Other sessions may last longer, usually with one or both of the communicating parties able to terminate it
- For Internet applications, each session is related to a particular port
- A session is typically implemented as a layer in a network
protocol (e.g. telnet, FTP)

- It keeps you from having to ask "oh, is it you again?" every time you receive a request 
  - This is especially important in today's e-commerce Web apps
  - A Web shopping cart, for example, needs to accurately reflect a user's choices at every step in the process
- **Stateful** protocols, such as telnet and FTP, can process multiple operations before closing a connection. The server knows that all requests came from a single person.
- HTTP is a **stateless** protocol, which means every time a client asks for a Web page, the protocol opens a separate connection to the server, and the server doesn't know the
context from one connection to the next.

  <img src="../pics/8.PNG" alt="Servlets" width="450"/>

- **Servlet engine** assigns each connection a unique ID and gives that to the client when the session gets established
  - Client uses that ID in subsequent requests 
  - Servlet engine can can map each request to a particular session
- Four different techniques 
  - URL Rewriting 
    - Is the **lowest common denominator of session managment** 
    - Involves adding data to the URL that can be interpreted by the container on the next request with a session
    - Name of the parameter (e.g. jsessionid) depends on the server 
    - e.g. http://server.com/catalog/index.html?jsessionid=1234

- Cookie 
  - Most used session tracking mechanism 
  - Container sends a cookie to the client and the client will then return the cookie on each subsequent request 
  - **Relies on the browser allowing cookies**
- HTTPSession class 
  - No need to worry about generating a unique session ID or storing it
  - For browsers that support cookies, a temporary identifier will be issued, and then echoed back by the browser every time a request is made
- Session token in hidden fields 
  - < INPUT TYPE="**HIDDEN**" NAME="session" VALUE="...">
  - E.g. ASP.NET used this approach

#### URL Rewriting
- URL Rewriting 
  - Is a good solution, especially if users have disabled cookies 
  - But be sure to consider the following: 
    -  You have to be sure to append the information **to every URL** that references your site
    - Appending parameters brings up privacy issues 
        - You may not want the actual data you are tracking to be visible
    - Loophole with this technique: 
        - Users can leave the session and come back using a bookmark, in which
case your session information is lost

#### Cookie Overview

- Cookies are a way for a server (or a servlet, as part of a server) **to send some information to a client to store**, and for the server to **later retrieve its data from that client**
- Servlets send cookies to clients by **adding fields to HTTP response headers**
- Clients automatically return cookies by adding fields to HTTP request headers
- Subsequent sessions can access the cookie to extract information
- Cookies store information about a session in a humanreadable file on the client's machine
- Common approach for session tracking

#### Characteristics of a Cookie

- Name of the cookie must be an HTTP/1.1 token 
- Constraints
    - A cookie cannot grow more than **4K in size** 
    -  No domain can have more than **50 cookies**
    -  A browser can support at least **3.000 cookies** in total
- Privacy concerns for users 
    - Some people don't like the fact that a program can store and retrieve information about their habits
    - **Sensitive information**, e.g. a credit card number could be stored in a cookie
    - It is easy to use cookies inappropriately
    - As a result, some users disable cookies or delete them altogether

#### Cookie Properties

- Domain 
    - This determines which servers can receive the cookie 
    - By default cookies are sent to the server that originally sent the cookie to the client
    - The domain is specified in the form ".google.com", indicating that all servers ending with .google.com can receive this cookie
- Path 
  - Sets the "target” URL indicating the directories on the server that lead to the services that can receive this cookie
  - Cookies can be "targeted” to specific URLs that include directories on the Web server. By default a cookie is returned to services operating in the same directory as the service that sent the cookie or a subdirectory
of that directory

  <img src="../pics/9.PNG" alt="Servlets" width="450"/>

- Expires and MaxAge 
    - Expires attribute defines **a specific date and time** for when the browser should delete the cookie
    - Alternatively, the Max-Age attribute can be used to set the cookie's **expiration as an interval of seconds in the future**, relative to the time the browser received the cookie
- Secure and HttpOnly 
    - Secure attribute is meant to keep cookie communication limited to **encrypted transmission**  
Does not have an expiration date, making it a session cookie. It will be deleted after the user closes their browser.
    - HttpOnly attribute directs browsers **not to expose cookies through channels other than HTTP** (and HTTPS) requests. This means that the cookie cannot be accessed via client-side scripting languages (notably JavaScript), and therefore **cannot be stolen easily via cross-site scripting**.
  
  <img src="../pics/10.PNG" alt="Servlets" width="500"/>

#### Sending a Cookie

- Cookies are sent **as headers** of the response to the client
  
```java
//remember it by adding a cookie 
if (userId != null) { 
    Cookie c = new Cookie("UserID", userId);
    response.addCookie(c);
```

#### Retrieving a Cookie

```java
// Find the cookie and remove it 
Cookie[] cookies = request.getCookies(); 
for(i=0; i < cookies.length; i++) { 
    Cookie thisCookie = cookie[i]; 
    if (thisCookie.getName().equals("UserID") && 
        thisCookie.getValue().equals(userId)) { 
          // Delete the cookie
          thisCookie.setMaxAge(0);
```

#### Session implications

- If the User-ID authorizes access to a particular resource, then anyone who runs the Web browser can gain access
- In shared environments (such as Internet cafe terminals, or offices), other people can access the browser and masquerade as a particular user
- Solution is 
    - Specify a very **short expiration date** (for example, in two minutes) and to periodically refresh the cookie as new requests come in
    - Provide a "**logout**" function 
        - This allows users to close their account, so that no further access can be gained without specifying a password or being authenticated
        - Some Web applications (e.g. BA Online-B@nking) warn users, if they haven‘t logged out properly, when they log in again
    - Use HttpSession class instead (will be discussed later)

#### Third-Party Cookie

- Normally, a cookie's domain attribute will match the domain that is shown in the web browser's address bar -> **first party cookie**
- A **third-party cookie**, however, belongs to a **domain different** from the one shown in the address bar.
- This sort of cookie typically appears when web pages feature content from **external websites, such as banner advertisements**
- This opens up the **potential for tracking the user's browsing history**, and is often used by advertisers in an effort to serve
relevant advertisements to each user

  <img src="../pics/11.PNG" alt="Servlets" width="500"/>

#### URL Rewriting

- When you use URL rewriting you call methods that, when necessary, **include the session ID in a link**
- **You must call these methods for every link** in the servlet response
- HttpServletResponse.encodeURL associates a session
ID with a URL

- e.g. CatalogServlet
  
```java
public void doGet (HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
...
    for(int i=0; i < numBooks; i++) { ...
        //Print out info on each book in its own two rows 
        out.println("<tr>" + ... 
        "<a href=\"" 
        + response.encodeURL("/bookstore/bookdetails?bookId=" 
        + bookId) + "\"> <strong>" 
        + books[i].getTitle() + " </strong></a></td> + ...
        "<a href=\"" + response.encodeURL("/bookstore/catalog?Buy=" + bookId) 
        + "\"> Add to Cart </a></td></tr>" +
    }
}
```

#### Characteristics

- If the user clicks on a link with a rewritten URL, the servlet recognizes and extracts the session ID
- If the user's browser does not support cookies and the user clicks on an **un-rewritten URL**, the user's **session is lost** 
  - The servlet contacted through that link creates a new session, but the new session does not have the data associated with the previous session
  - Once a servlet loses the session data, the data is lost for all servlets that share the session.
- **Consistently use URL rewriting** if your servlet is to support
clients that do not support or accept cookies

#### Alternative approach with HttpSession class
  - No need to worry about generating a unique session ID or storing it
  - For browsers that support cookies, a temporary identifier will be issued, and then echoed back by the browser every time a request is made
  - If cookies are not supported, then a servlet can use the technique of URL re-writing to encode a session identifier in every hyperlink
#### Advantages 
  - Session approach is simpler for the developer 
    - No need to constantly refresh cookies or to write code to expire them
  - Less network utilization
    - State data is kept on the server side

#### Important methods in HTTPSession class 
- isNew 
    - Returns true if the client doesn't yet know about the session. If the client has disabled cookies, then a session is new on each request.
- getId 
    - Returns a string containing the unique identifier assigned to this session. Useful when using URL rewriting to identify the session.
- setAttribute, getAttribute 
    - Binds an object to this session, using the name specified. 
    - Returns the object (with the specified name) bound in this session.
- setMaxInactiveInterval 
    - Specifies the time between client requests before the servlet invalidates this session. A negative time indicates the session should never timeout.
- Invalidate 
    - Expires the current session and unbinds the object bound to it.